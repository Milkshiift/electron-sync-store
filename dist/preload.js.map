{
  "version": 3,
  "sources": ["../src/preload.ts", "../src/types.ts"],
  "sourcesContent": [
    "import { ipcRenderer, type IpcRendererEvent } from \"electron\";\nimport { Channels, type Listener, type Unsubscribe } from \"./types\";\n\nexport class StoreClient<T> {\n    private state: T | undefined;\n    private listeners = new Set<Listener<T>>();\n    private readyPromise: Promise<T>;\n    private channelChange: string;\n\n    private handleParamsChange = (_: IpcRendererEvent, data: T) => {\n        this.state = data;\n        this.notify();\n    };\n\n    constructor(private name: string) {\n        this.channelChange = Channels.ON_CHANGE(name);\n        ipcRenderer.on(this.channelChange, this.handleParamsChange);\n\n        this.readyPromise = ipcRenderer.invoke(Channels.GET(name)).then((data: T) => {\n            if (this.state === undefined) {\n                this.state = data;\n                this.notify();\n            }\n            return this.state!;\n        });\n    }\n\n    public ready(): Promise<T> {\n        return this.readyPromise;\n    }\n\n    public get(): Readonly<T> {\n        if (this.state === undefined) throw new Error(`Store \"${this.name}\" not hydrated`);\n        return this.state;\n    }\n\n    public async set(value: T): Promise<void> {\n        this.state = value;\n        this.notify();\n\n        try {\n            await ipcRenderer.invoke(Channels.SET(this.name), value);\n        } catch (e) {\n            console.error(`Store \"${this.name}\" sync failed`, e);\n            // Revert/Resync on error\n            this.state = await ipcRenderer.invoke(Channels.GET(this.name));\n            this.notify();\n        }\n    }\n\n    public subscribe(cb: Listener<T>): Unsubscribe {\n        this.listeners.add(cb);\n        if (this.state !== undefined) cb(this.state);\n        return () => this.listeners.delete(cb);\n    }\n\n    private notify(): void {\n        if (this.state === undefined) return;\n        for (const cb of this.listeners) cb(this.state);\n    }\n\n    public dispose(): void {\n        ipcRenderer.removeListener(this.channelChange, this.handleParamsChange);\n        this.listeners.clear();\n    }\n}\n\nexport function createClient<T>(name: string): StoreClient<T> {\n    return new StoreClient(name);\n}",
    "export interface Middleware<T> {\n    onHydrate?: () => T | Promise<T | null | undefined>;\n    onPersist?: (state: Readonly<T>) => void | Promise<void>;\n}\n\nexport type Listener<T> = (state: Readonly<T>) => void;\nexport type Unsubscribe = () => void;\n\n/** @internal */\nexport const Channels = {\n    GET: (name: string) => `store:${name}:get`,\n    SET: (name: string) => `store:${name}:set`,\n    ON_CHANGE: (name: string) => `store:${name}:changed`,\n};"
  ],
  "mappings": "AAAA,sBAAS,iBCSF,IAAM,EAAW,CACpB,IAAK,CAAC,IAAiB,SAAS,QAChC,IAAK,CAAC,IAAiB,SAAS,QAChC,UAAW,CAAC,IAAiB,SAAS,WAC1C,EDVO,MAAM,CAAe,CAWJ,KAVZ,MACA,UAAY,IAAI,IAChB,aACA,cAEA,mBAAqB,CAAC,EAAqB,IAAY,CAC3D,KAAK,MAAQ,EACb,KAAK,OAAO,GAGhB,WAAW,CAAS,EAAc,CAAd,YAChB,KAAK,cAAgB,EAAS,UAAU,CAAI,EAC5C,EAAY,GAAG,KAAK,cAAe,KAAK,kBAAkB,EAE1D,KAAK,aAAe,EAAY,OAAO,EAAS,IAAI,CAAI,CAAC,EAAE,KAAK,CAAC,IAAY,CACzE,GAAI,KAAK,QAAU,OACf,KAAK,MAAQ,EACb,KAAK,OAAO,EAEhB,OAAO,KAAK,MACf,EAGE,KAAK,EAAe,CACvB,OAAO,KAAK,aAGT,GAAG,EAAgB,CACtB,GAAI,KAAK,QAAU,OAAW,MAAU,MAAM,UAAU,KAAK,oBAAoB,EACjF,OAAO,KAAK,WAGH,IAAG,CAAC,EAAyB,CACtC,KAAK,MAAQ,EACb,KAAK,OAAO,EAEZ,GAAI,CACA,MAAM,EAAY,OAAO,EAAS,IAAI,KAAK,IAAI,EAAG,CAAK,EACzD,MAAO,EAAG,CACR,QAAQ,MAAM,UAAU,KAAK,oBAAqB,CAAC,EAEnD,KAAK,MAAQ,MAAM,EAAY,OAAO,EAAS,IAAI,KAAK,IAAI,CAAC,EAC7D,KAAK,OAAO,GAIb,SAAS,CAAC,EAA8B,CAE3C,GADA,KAAK,UAAU,IAAI,CAAE,EACjB,KAAK,QAAU,OAAW,EAAG,KAAK,KAAK,EAC3C,MAAO,IAAM,KAAK,UAAU,OAAO,CAAE,EAGjC,MAAM,EAAS,CACnB,GAAI,KAAK,QAAU,OAAW,OAC9B,QAAW,KAAM,KAAK,UAAW,EAAG,KAAK,KAAK,EAG3C,OAAO,EAAS,CACnB,EAAY,eAAe,KAAK,cAAe,KAAK,kBAAkB,EACtE,KAAK,UAAU,MAAM,EAE7B,CAEO,SAAS,CAAe,CAAC,EAA8B,CAC1D,OAAO,IAAI,EAAY,CAAI",
  "debugId": "F07A41A437D898BA64756E2164756E21",
  "names": []
}