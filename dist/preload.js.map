{
  "version": 3,
  "sources": ["../src/preload.ts", "../src/types.ts", "../src/shared.ts"],
  "sourcesContent": [
    "import { ipcRenderer, type IpcRendererEvent } from \"electron\";\nimport { Channels, type Listener, type StoreOptions, type Unsubscribe, type DeepPartial } from \"./types\";\nimport { clone, deepMerge } from \"./shared\";\n\n/**\n * The Renderer process client.\n * synchronizes state with the Main process and handles optimistic updates.\n */\nexport class StoreClient<T> {\n    private state: T;\n    private listeners = new Set<Listener<T>>();\n    private options: StoreOptions<T>;\n    private readyPromise: Promise<T>;\n    private isHydrated = false;\n\n    constructor(options: StoreOptions<T>) {\n        this.options = options;\n        this.state = clone(options.defaults);\n\n        // Listen for server-side changes\n        ipcRenderer.on(Channels.ON_CHANGE(options.name), (_: IpcRendererEvent, data: T) => {\n            this.isHydrated = true;\n            this.state = data;\n            this.notify();\n        });\n\n        // Request initial state immediately\n        this.readyPromise = ipcRenderer.invoke(Channels.GET(options.name))\n            .then((data) => {\n                // If we received an update via ON_CHANGE while waiting, discard this stale initial data\n                if (!this.isHydrated) {\n                    this.state = data;\n                    this.isHydrated = true;\n                    this.notify();\n                }\n                return this.state;\n            })\n            .catch((err) => {\n                console.error(`[StoreClient] Init failed`, err);\n                throw err;\n            });\n    }\n\n    /**\n     * Returns a promise that resolves with the state when the initial synchronization is complete.\n     */\n    public async ready(): Promise<T> {\n        return this.readyPromise;\n    }\n\n    public get(): T {\n        return clone(this.state);\n    }\n\n    public getKey<K extends keyof T>(key: K): T[K] {\n        return clone(this.state[key]);\n    }\n\n    /**\n     * Updates the state.\n     * If `optimistic` is enabled in options, the local state updates immediately.\n     * If the IPC call fails, the state rolls back to the previous version.\n     */\n    public async set(update: DeepPartial<T> | T): Promise<void> {\n        if (!this.options.optimistic) {\n            // Standard Mode: Round-trip to Main before updating UI\n            await ipcRenderer.invoke(Channels.SET(this.options.name), update);\n            return;\n        }\n\n        // Optimistic Mode\n        await this.performOptimisticUpdate(\n            () => deepMerge(this.state, update),\n            () => ipcRenderer.invoke(Channels.SET(this.options.name), update)\n        );\n    }\n\n    public async setKey<K extends keyof T>(key: K, value: T[K]): Promise<void> {\n        const safeValue = clone(value);\n\n        if (!this.options.optimistic) {\n            await ipcRenderer.invoke(Channels.SET_KEY(this.options.name), key, safeValue);\n            return;\n        }\n\n        await this.performOptimisticUpdate(\n            () => {\n                const s = clone(this.state);\n                s[key] = safeValue;\n                return s;\n            },\n            () => ipcRenderer.invoke(Channels.SET_KEY(this.options.name), key, safeValue)\n        );\n    }\n\n    public async reset(): Promise<void> {\n        await ipcRenderer.invoke(Channels.RESET(this.options.name));\n    }\n\n    /**\n     * Subscribes to state changes.\n     * @returns An unsubscribe function.\n     */\n    public subscribe(cb: Listener<T>): Unsubscribe {\n        this.listeners.add(cb);\n        // Immediate callback with current state\n        cb(clone(this.state));\n        return () => { this.listeners.delete(cb); };\n    }\n\n    private notify() {\n        const s = clone(this.state);\n        for (const cb of this.listeners) cb(s);\n    }\n\n    private async performOptimisticUpdate(calcState: () => T, action: () => Promise<void>) {\n        const previousState = clone(this.state);\n        const expectedState = calcState();\n\n        this.state = expectedState;\n        this.notify();\n\n        try {\n            await action();\n        } catch (err) {\n            console.error(`[StoreClient] Sync failed, rolling back.`, err);\n\n            // Rollback only if state matches our optimistic expectation.\n            // If it doesn't match, it means an external update happened in the meantime,\n            // and rolling back would overwrite valid data.\n            if (JSON.stringify(this.state) === JSON.stringify(expectedState)) {\n                this.state = previousState;\n                this.notify();\n            }\n            throw err;\n        }\n    }\n}\n\n/**\n * Creates a new StoreClient instance in the Renderer process.\n */\nexport function createClient<T>(options: StoreOptions<T>) {\n    return new StoreClient(options);\n}",
    "export interface StoreOptions<T> {\n    /** Unique name for the store (used for IPC channels). */\n    name: string;\n    /** The initial default state. */\n    defaults: T;\n    /**\n     * If true, the renderer updates the UI immediately before syncing with Main.\n     * If the sync fails, the state automatically rolls back.\n     * @default false\n     */\n    optimistic?: boolean;\n    /** Optional validator. Returns sanitized state or throws error to cancel update. */\n    validate?: (data: unknown) => T;\n}\n\nexport interface Middleware<T> {\n    /** Run on initialization. Return object to merge into initial state. */\n    onHydrate?: () => T | Promise<T | null | undefined>;\n    /** Run after every state change. Use for saving to disk/DB. */\n    onPersist?: (state: T) => void | Promise<void>;\n}\n\nexport type Listener<T> = (state: T) => void;\nexport type Unsubscribe = () => void;\n\n/** Recursive partial type helper */\nexport type DeepPartial<T> = T extends object ? {\n    [P in keyof T]?: DeepPartial<T[P]>;\n} : T;\n\n/**\n * Internal IPC Channel definitions.\n * @internal\n */\nexport const Channels = {\n    GET: (name: string) => `store:${name}:get`,\n    SET: (name: string) => `store:${name}:set`,\n    SET_KEY: (name: string) => `store:${name}:set-key`,\n    RESET: (name: string) => `store:${name}:reset`,\n    ON_CHANGE: (name: string) => `store:${name}:changed`,\n};",
    "import type { StoreOptions } from \"./types\";\n\n/**\n * Type helper for defining store configuration with type inference.\n */\nexport function defineStore<T>(config: StoreOptions<T>): StoreOptions<T> {\n    return config;\n}\n\n/**\n * deeply clones a value using structuredClone (modern) or JSON fallback.\n */\nexport function clone<T>(data: T): T {\n    try {\n        return structuredClone(data);\n    } catch (e) {\n        return JSON.parse(JSON.stringify(data));\n    }\n}\n\n/**\n * Checks if a value is a plain object (not null, not array, not date, etc).\n */\nexport function isPlainObject(item: unknown): item is Record<string, any> {\n    return (\n        item !== null &&\n        typeof item === \"object\" &&\n        !Array.isArray(item) &&\n        !(item instanceof Date) &&\n        !(item instanceof RegExp)\n    );\n}\n\n/**\n * Deep merges a partial source object into a target object.\n * Handles recursion, Arrays, Dates, and RegExps.\n * Returns a new object reference (immutable).\n *\n * NOTE: Arrays are replaced, not merged.\n * NOTE: `undefined` values in source will delete the corresponding key in target.\n */\nexport function deepMerge<T>(target: T, source: any): T {\n    // If source is explicitly undefined, return undefined to signal deletion\n    if (source === undefined) {\n        return undefined as unknown as T;\n    }\n\n    // If either is not a plain object (e.g. Array, Date, null, primitive), source replaces target.\n    if (!isPlainObject(target) || !isPlainObject(source)) {\n        return clone(source);\n    }\n\n    const output = { ...target } as any;\n\n    for (const key of Object.keys(source)) {\n        // Prevent prototype pollution\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n            continue;\n        }\n\n        const sourceValue = source[key];\n        const targetValue = output[key];\n\n        if (sourceValue === undefined) {\n            delete output[key];\n        } else {\n            // Recursively merge\n            output[key] = deepMerge(targetValue, sourceValue);\n        }\n    }\n\n    return output;\n}"
  ],
  "mappings": "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",
  "debugId": "09006B3F88B5CDC864756E2164756E21",
  "names": []
}