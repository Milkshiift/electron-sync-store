{
  "version": 3,
  "sources": ["../src/main.ts", "../src/types.ts", "../src/shared.ts"],
  "sourcesContent": [
    "import { BrowserWindow, ipcMain, type IpcMainInvokeEvent } from \"electron\";\nimport { Channels, type Middleware, type StoreOptions, type DeepPartial } from \"./types\";\nimport { clone, deepMerge } from \"./shared\";\n\n/**\n * The Main process host for the state store.\n * Manages the source of truth, persistence middleware, and broadcasting updates to renderers.\n */\nexport class StoreHost<T> {\n    private state: T;\n    private options: StoreOptions<T>;\n    private middleware: Middleware<T>[];\n    private initPromise: Promise<void>;\n\n    private persistenceQueue: Promise<void> = Promise.resolve();\n\n    constructor(options: StoreOptions<T>, middleware: Middleware<T>[] = []) {\n        this.options = options;\n        this.state = clone(options.defaults);\n        this.middleware = middleware;\n\n        this.initPromise = this.init();\n        this.registerIpc();\n    }\n\n    /**\n     * Hydrates state from middleware (e.g., file system), validates it, and broadcasts readiness.\n     */\n    private async init() {\n        for (const mw of this.middleware) {\n            if (mw.onHydrate) {\n                const loaded = await mw.onHydrate();\n                if (loaded) this.state = deepMerge(this.state, loaded);\n            }\n        }\n        if (this.options.validate) {\n            this.state = this.options.validate(this.state);\n        }\n    }\n\n    /**\n     * Returns a deep copy of the current state.\n     */\n    public get(): T {\n        return clone(this.state);\n    }\n\n    /**\n     * Updates the state with a partial object, runs validation, executes persistence middleware, and notifies renderers.\n     */\n    public async set(partial: DeepPartial<T> | T) {\n        await this.initPromise;\n\n        const newState = deepMerge(this.state, partial);\n        await this.applyState(newState);\n    }\n\n    /**\n     * Updates a specific top-level key by replacing it entirely.\n     * Use this when you need to remove keys from an object by omitting them,\n     * rather than merging.\n     */\n    public async setKey<K extends keyof T>(key: K, value: T[K]) {\n        await this.initPromise;\n\n        const newState = clone(this.state);\n        newState[key] = value;\n        await this.applyState(newState);\n    }\n\n    private async applyState(newState: T) {\n        if (this.options.validate) {\n            try {\n                newState = this.options.validate(newState);\n            } catch (err) {\n                // Validation failed, abort update\n                throw err;\n            }\n        }\n\n        // Performance: Skip broadcast/persist if state effectively didn't change\n        if (JSON.stringify(this.state) === JSON.stringify(newState)) return;\n\n        this.state = newState;\n\n        this.broadcast();\n\n        // Execute persistence hooks (non-blocking for UI, but awaited for data safety)\n        this.persistenceQueue = this.persistenceQueue\n            .then(() => Promise.all(\n                this.middleware.map(mw =>\n                    mw.onPersist ? Promise.resolve(mw.onPersist(this.state)).catch(e => console.error(e)) : undefined\n                )\n            ))\n            .then(() => {});\n    }\n\n    /**\n     * Pushes the current state to all active browser windows.\n     */\n    private broadcast() {\n        const channel = Channels.ON_CHANGE(this.options.name);\n        for (const win of BrowserWindow.getAllWindows()) {\n            if (!win.isDestroyed() && !win.webContents.isDestroyed()) {\n                win.webContents.send(channel, this.state);\n            }\n        }\n    }\n\n    /**\n     * Registers IPC handlers. Removes existing handlers for the same store name to support hot-reloading.\n     */\n    private registerIpc() {\n        const { name } = this.options;\n        const bind = (channel: string, fn: (e: IpcMainInvokeEvent, ...args: any[]) => Promise<any>) => {\n            ipcMain.removeHandler(channel);\n            ipcMain.handle(channel, async (e, ...args) => {\n                await this.initPromise;\n                return fn(e, ...args);\n            });\n        };\n\n        bind(Channels.GET(name), async () => {\n            return this.get();\n        });\n\n        bind(Channels.SET(name), async (_, u: DeepPartial<T>) => {\n            await this.set(u);\n        });\n\n        bind(Channels.SET_KEY(name), async (_, key: keyof T, val: any) => {\n            await this.setKey(key, val);\n        });\n\n        bind(Channels.RESET(name), async () => {\n            await this.applyState(clone(this.options.defaults));\n        });\n    }\n\n    /**\n     * Resolves when the store has finished its initial hydration cycle.\n     */\n    public async ready() {\n        await this.initPromise;\n    }\n}\n\n/**\n * Creates a new StoreHost instance in the Main process.\n */\nexport function createHost<T>(options: StoreOptions<T>, ...middleware: Middleware<T>[]) {\n    return new StoreHost(options, middleware);\n}",
    "export interface StoreOptions<T> {\n    /** Unique name for the store (used for IPC channels). */\n    name: string;\n    /** The initial default state. */\n    defaults: T;\n    /**\n     * If true, the renderer updates the UI immediately before syncing with Main.\n     * If the sync fails, the state automatically rolls back.\n     * @default false\n     */\n    optimistic?: boolean;\n    /** Optional validator. Returns sanitized state or throws error to cancel update. */\n    validate?: (data: unknown) => T;\n}\n\nexport interface Middleware<T> {\n    /** Run on initialization. Return object to merge into initial state. */\n    onHydrate?: () => T | Promise<T | null | undefined>;\n    /** Run after every state change. Use for saving to disk/DB. */\n    onPersist?: (state: T) => void | Promise<void>;\n}\n\nexport type Listener<T> = (state: T) => void;\nexport type Unsubscribe = () => void;\n\n/** Recursive partial type helper */\nexport type DeepPartial<T> = T extends object ? {\n    [P in keyof T]?: DeepPartial<T[P]>;\n} : T;\n\n/**\n * Internal IPC Channel definitions.\n * @internal\n */\nexport const Channels = {\n    GET: (name: string) => `store:${name}:get`,\n    SET: (name: string) => `store:${name}:set`,\n    SET_KEY: (name: string) => `store:${name}:set-key`,\n    RESET: (name: string) => `store:${name}:reset`,\n    ON_CHANGE: (name: string) => `store:${name}:changed`,\n};",
    "import type { StoreOptions } from \"./types\";\n\n/**\n * Type helper for defining store configuration with type inference.\n */\nexport function defineStore<T>(config: StoreOptions<T>): StoreOptions<T> {\n    return config;\n}\n\n/**\n * deeply clones a value using structuredClone (modern) or JSON fallback.\n */\nexport function clone<T>(data: T): T {\n    try {\n        return structuredClone(data);\n    } catch (e) {\n        return JSON.parse(JSON.stringify(data));\n    }\n}\n\n/**\n * Checks if a value is a plain object (not null, not array, not date, etc).\n */\nexport function isPlainObject(item: unknown): item is Record<string, any> {\n    return (\n        item !== null &&\n        typeof item === \"object\" &&\n        !Array.isArray(item) &&\n        !(item instanceof Date) &&\n        !(item instanceof RegExp)\n    );\n}\n\n/**\n * Deep merges a partial source object into a target object.\n * Handles recursion, Arrays, Dates, and RegExps.\n * Returns a new object reference (immutable).\n *\n * NOTE: Arrays are replaced, not merged.\n * NOTE: `undefined` values in source will delete the corresponding key in target.\n */\nexport function deepMerge<T>(target: T, source: any): T {\n    // If source is explicitly undefined, return undefined to signal deletion\n    if (source === undefined) {\n        return undefined as unknown as T;\n    }\n\n    // If either is not a plain object (e.g. Array, Date, null, primitive), source replaces target.\n    if (!isPlainObject(target) || !isPlainObject(source)) {\n        return clone(source);\n    }\n\n    const output = { ...target } as any;\n\n    for (const key of Object.keys(source)) {\n        // Prevent prototype pollution\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n            continue;\n        }\n\n        const sourceValue = source[key];\n        const targetValue = output[key];\n\n        if (sourceValue === undefined) {\n            delete output[key];\n        } else {\n            // Recursively merge\n            output[key] = deepMerge(targetValue, sourceValue);\n        }\n    }\n\n    return output;\n}"
  ],
  "mappings": "AAAA,wBAAS,aAAe,iBCkCjB,IAAM,EAAW,CACpB,IAAK,CAAC,IAAiB,SAAS,QAChC,IAAK,CAAC,IAAiB,SAAS,QAChC,QAAS,CAAC,IAAiB,SAAS,YACpC,MAAO,CAAC,IAAiB,SAAS,UAClC,UAAW,CAAC,IAAiB,SAAS,WAC1C,EC5BO,SAAS,CAAQ,CAAC,EAAY,CACjC,GAAI,CACA,OAAO,gBAAgB,CAAI,EAC7B,MAAO,EAAG,CACR,OAAO,KAAK,MAAM,KAAK,UAAU,CAAI,CAAC,GAOvC,SAAS,CAAa,CAAC,EAA4C,CACtE,OACI,IAAS,MACT,OAAO,IAAS,UAChB,CAAC,MAAM,QAAQ,CAAI,GACnB,EAAE,aAAgB,OAClB,EAAE,aAAgB,QAYnB,SAAS,CAAY,CAAC,EAAW,EAAgB,CAEpD,GAAI,IAAW,OACX,OAIJ,GAAI,CAAC,EAAc,CAAM,GAAK,CAAC,EAAc,CAAM,EAC/C,OAAO,EAAM,CAAM,EAGvB,IAAM,EAAS,IAAK,CAAO,EAE3B,QAAW,KAAO,OAAO,KAAK,CAAM,EAAG,CAEnC,GAAI,IAAQ,aAAe,IAAQ,eAAiB,IAAQ,YACxD,SAGJ,IAAM,EAAc,EAAO,GACrB,EAAc,EAAO,GAE3B,GAAI,IAAgB,OAChB,OAAO,EAAO,GAGd,OAAO,GAAO,EAAU,EAAa,CAAW,EAIxD,OAAO,EF/DJ,MAAM,CAAa,CACd,MACA,QACA,WACA,YAEA,iBAAkC,QAAQ,QAAQ,EAE1D,WAAW,CAAC,EAA0B,EAA8B,CAAC,EAAG,CACpE,KAAK,QAAU,EACf,KAAK,MAAQ,EAAM,EAAQ,QAAQ,EACnC,KAAK,WAAa,EAElB,KAAK,YAAc,KAAK,KAAK,EAC7B,KAAK,YAAY,OAMP,KAAI,EAAG,CACjB,QAAW,KAAM,KAAK,WAClB,GAAI,EAAG,UAAW,CACd,IAAM,EAAS,MAAM,EAAG,UAAU,EAClC,GAAI,EAAQ,KAAK,MAAQ,EAAU,KAAK,MAAO,CAAM,EAG7D,GAAI,KAAK,QAAQ,SACb,KAAK,MAAQ,KAAK,QAAQ,SAAS,KAAK,KAAK,EAO9C,GAAG,EAAM,CACZ,OAAO,EAAM,KAAK,KAAK,OAMd,IAAG,CAAC,EAA6B,CAC1C,MAAM,KAAK,YAEX,IAAM,EAAW,EAAU,KAAK,MAAO,CAAO,EAC9C,MAAM,KAAK,WAAW,CAAQ,OAQrB,OAAyB,CAAC,EAAQ,EAAa,CACxD,MAAM,KAAK,YAEX,IAAM,EAAW,EAAM,KAAK,KAAK,EACjC,EAAS,GAAO,EAChB,MAAM,KAAK,WAAW,CAAQ,OAGpB,WAAU,CAAC,EAAa,CAClC,GAAI,KAAK,QAAQ,SACb,GAAI,CACA,EAAW,KAAK,QAAQ,SAAS,CAAQ,EAC3C,MAAO,EAAK,CAEV,MAAM,EAKd,GAAI,KAAK,UAAU,KAAK,KAAK,IAAM,KAAK,UAAU,CAAQ,EAAG,OAE7D,KAAK,MAAQ,EAEb,KAAK,UAAU,EAGf,KAAK,iBAAmB,KAAK,iBACxB,KAAK,IAAM,QAAQ,IAChB,KAAK,WAAW,IAAI,KAChB,EAAG,UAAY,QAAQ,QAAQ,EAAG,UAAU,KAAK,KAAK,CAAC,EAAE,MAAM,KAAK,QAAQ,MAAM,CAAC,CAAC,EAAI,MAC5F,CACJ,CAAC,EACA,KAAK,IAAM,EAAE,EAMd,SAAS,EAAG,CAChB,IAAM,EAAU,EAAS,UAAU,KAAK,QAAQ,IAAI,EACpD,QAAW,KAAO,EAAc,cAAc,EAC1C,GAAI,CAAC,EAAI,YAAY,GAAK,CAAC,EAAI,YAAY,YAAY,EACnD,EAAI,YAAY,KAAK,EAAS,KAAK,KAAK,EAQ5C,WAAW,EAAG,CAClB,IAAQ,QAAS,KAAK,QAChB,EAAO,CAAC,EAAiB,IAAgE,CAC3F,EAAQ,cAAc,CAAO,EAC7B,EAAQ,OAAO,EAAS,MAAO,KAAM,IAAS,CAE1C,OADA,MAAM,KAAK,YACJ,EAAG,EAAG,GAAG,CAAI,EACvB,GAGL,EAAK,EAAS,IAAI,CAAI,EAAG,SAAY,CACjC,OAAO,KAAK,IAAI,EACnB,EAED,EAAK,EAAS,IAAI,CAAI,EAAG,MAAO,EAAG,IAAsB,CACrD,MAAM,KAAK,IAAI,CAAC,EACnB,EAED,EAAK,EAAS,QAAQ,CAAI,EAAG,MAAO,EAAG,EAAc,IAAa,CAC9D,MAAM,KAAK,OAAO,EAAK,CAAG,EAC7B,EAED,EAAK,EAAS,MAAM,CAAI,EAAG,SAAY,CACnC,MAAM,KAAK,WAAW,EAAM,KAAK,QAAQ,QAAQ,CAAC,EACrD,OAMQ,MAAK,EAAG,CACjB,MAAM,KAAK,YAEnB,CAKO,SAAS,CAAa,CAAC,KAA6B,EAA6B,CACpF,OAAO,IAAI,EAAU,EAAS,CAAU",
  "debugId": "A5D4035C7DD2B27864756E2164756E21",
  "names": []
}