import{ipcRenderer as H}from"electron";var E={GET:(q)=>`store:${q}:get`,SET:(q)=>`store:${q}:set`,RESET:(q)=>`store:${q}:reset`,ON_CHANGE:(q)=>`store:${q}:changed`};function B(q){try{return structuredClone(q)}catch(z){return JSON.parse(JSON.stringify(q))}}function J(q,z){if(!G(z)||!G(q))return G(z)?B(z):z;if(z instanceof Date)return new Date(z.getTime());if(z instanceof RegExp)return new RegExp(z);if(Array.isArray(z))return B(z);if(Array.isArray(q)||q instanceof Date||q instanceof RegExp)return B(z);let A={...q};for(let D of Object.keys(z)){if(D==="__proto__"||D==="constructor"||D==="prototype")continue;let K=A[D],F=z[D];if(L(K)&&L(F))A[D]=J(K,F);else A[D]=G(F)?B(F):F}return A}function G(q){return q!==null&&typeof q==="object"}function L(q){return G(q)&&!Array.isArray(q)&&!(q instanceof Date)&&!(q instanceof RegExp)}class N{state;listeners=new Set;options;readyPromise;constructor(q){this.options=q,this.state=B(q.defaults),H.on(E.ON_CHANGE(q.name),(z,A)=>{this.state=A,this.notify()}),this.readyPromise=H.invoke(E.GET(q.name)).then((z)=>{return this.state=z,this.notify(),z}).catch((z)=>{return console.error("[StoreClient] Init failed",z),this.state})}async ready(){return this.readyPromise}get(){return B(this.state)}getKey(q){return B(this.state[q])}async set(q){if(!this.options.optimistic){await H.invoke(E.SET(this.options.name),q);return}let z=this.state,A=J(B(z),q);this.state=A,this.notify();try{await H.invoke(E.SET(this.options.name),q)}catch(D){if(console.error("[StoreClient] Sync failed, rolling back.",D),this.state===A)this.state=z,this.notify();throw D}}async setKey(q,z){let A={[q]:z};await this.set(A)}async reset(){await H.invoke(E.RESET(this.options.name))}subscribe(q){return this.listeners.add(q),q(B(this.state)),()=>{this.listeners.delete(q)}}notify(){let q=B(this.state);for(let z of this.listeners)z(q)}}function Y(q){return new N(q)}export{Y as createClient,N as StoreClient};

//# debugId=B8BC37251221069964756E2164756E21
